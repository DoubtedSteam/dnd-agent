# 玩家角色和响应格式化说明

## 概述

系统现在支持两个重要功能：
1. **玩家角色定义**：在场景中明确玩家扮演的角色
2. **响应格式化**：将Agent的JSON响应转换为适合玩家角色的文本

## 1. 玩家角色定义

### 在场景文件中定义

在 `SCENE.md` 文件的"基础信息"部分添加玩家角色：

```markdown
## 基础信息
- **时间**：黎明
- **地点**：绿雾边境小镇的冒险者公会大厅
- **背景**：...
- **玩家角色**：玩家扮演冒险者小队的队长/指挥者，负责协调队伍行动和做出决策。
```

### 作用

- **上下文理解**：LLM能够理解玩家指令的上下文
- **角色定位**：智能体知道玩家是谁，能够做出更合适的响应
- **指令适配**：根据玩家角色调整响应方式

### 自动提取

系统会自动从场景文件中提取玩家角色信息：
- 查找包含"玩家角色"或"玩家扮演"的行
- 提取角色描述
- 如果API调用时提供了`player_role`参数，优先使用参数值

## 2. 响应格式化

### 问题

Agent返回的是JSON格式：
```json
{
    "response": "好的，我们出发！",
    "state_changes": {...},
    "attribute_changes": {...}
}
```

直接返回给玩家会暴露JSON结构，体验不好。

### 解决方案

使用 `ResponseFormatter` 将JSON响应转换为适合玩家角色的文本：

1. **收集所有Agent响应**
2. **使用LLM格式化**：根据玩家角色，将响应转换为流畅的文本
3. **返回格式化后的文本**

### 格式化后的输出

**之前**（JSON格式）：
```json
{
    "responses": [
        {"character_name": "勇者", "response": "好的，我们出发！"}
    ]
}
```

**现在**（格式化文本）：
```json
{
    "responses": [
        {
            "character_name": "勇者",
            "formatted_text": "作为队长，你看到勇者艾伦举起盾牌，示意队伍前进。他坚定地说道：'好的，我们出发！保持警戒队形。'"
        }
    ],
    "summary": "队伍在你的指挥下开始行动，勇者在前方开路..."
}
```

## 工作流程

```
1. 玩家给出指令
   ↓
2. 加载场景（包含玩家角色信息）
   ↓
3. 提取玩家角色
   ↓
4. 发送指令给所有智能体（包含玩家角色信息）
   ↓
5. 智能体生成JSON响应
   ↓
6. 聚合响应
   ↓
7. 分析环境变化
   ↓
8. 【创建新存档步骤】从当前步骤复制到新步骤
   ↓
9. 【更新状态】在新步骤中更新角色状态和场景状态
   ↓
10. 【格式化响应】转换为适合玩家角色的文本（使用更新后的场景）
   ↓
11. 返回格式化后的文本给玩家
```

**重要**：
- 格式化响应在更新状态**之后**执行，这样可以使用更新后的场景信息
- 每次更新都会创建新的存档步骤，保留历史记录

## API使用

### 执行指令

```http
POST /api/themes/{theme}/execute
```

**请求体**：
```json
{
  "instruction": "我们出发去遗迹",
  "save_step": "0_step",
  "player_role": "冒险者小队队长",  // 可选，如果不提供会从场景中提取
  "platform": "deepseek"
}
```

**响应**：
```json
{
  "surface": {
    "responses": [
      {
        "character_name": "勇者",
        "formatted_text": "作为队长，你看到勇者艾伦举起盾牌..."
      }
    ],
    "summary": "队伍在你的指挥下开始行动..."
  },
  "hidden": {
    "state_changes": {...},
    "raw_responses": [...]  // 保留原始JSON响应
  },
  "new_step": "1_step"  // 新创建的存档步骤（如果提供了save_step）
}
```

**注意**：
- 如果提供了`save_step`，系统会自动创建新的存档步骤（如从`0_step`创建`1_step`）
- 所有状态更新都在新步骤中进行，保留历史记录

## 配置玩家角色

### 方法1：在场景文件中定义（推荐）

在 `characters/{theme}/SCENE.md` 或 `save/{theme}/{step}/SCENE.md` 中添加：

```markdown
- **玩家角色**：玩家扮演的角色描述
```

### 方法2：API调用时指定

```json
{
  "instruction": "...",
  "player_role": "自定义玩家角色"
}
```

## 响应格式化说明

### 格式化原则

1. **玩家视角**：以玩家角色的视角描述事件
2. **自然流畅**：将JSON结构转换为流畅的文本
3. **角色对话**：保留角色对话的原汁原味
4. **环境描述**：适当添加环境描述，让场景更生动

### 格式化示例

**输入**（Agent JSON响应）：
```json
{
  "response": "好的，我们出发！",
  "state_changes": {
    "surface": {"perceived_state": "显得更加专注"}
  }
}
```

**输出**（格式化文本）：
```
作为队长，你看到勇者艾伦举起盾牌，示意队伍前进。他显得更加专注，坚定地说道："好的，我们出发！保持警戒队形——凯在前方侦察，莉娜和艾米在中间，我殿后。"
```

## 注意事项

1. **玩家角色必须明确**：确保场景文件中定义了玩家角色
2. **格式化会消耗token**：每次响应格式化都会调用一次LLM
3. **原始响应保留**：格式化后的响应中保留原始JSON（在hidden字段中）
4. **fallback机制**：如果格式化失败，会使用简单格式化（直接使用response字段）

## 相关文件

- `services/response_formatter.py` - 响应格式化器
- `services/agent.py` - Agent类（已更新支持玩家角色）
- `services/multi_agent_coordinator.py` - 多智能体协调器（已集成格式化）
- `characters/{theme}/SCENE.md` - 场景文件（应包含玩家角色）

