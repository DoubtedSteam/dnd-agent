# 剧本系统开发计划

## 一、问题分析

### 当前问题
在实际使用中发现，LLM难以主动推进剧情，主要表现：
- 缺乏剧情发展方向指引
- 场景转换不够自然
- 事件触发时机不明确
- 角色行为缺乏剧情驱动

### 解决方案
引入**事件驱动的三层剧本系统**，让LLM作为导演动态推进剧情：
1. **故事总览层**：定义整体剧情框架和可用场景池（不预设路径）
2. **场景层**：详细描述每个场景，包含以"里"形式存在的事件触发条件
3. **角色层**：扩展角色背景，增强剧情关联性

**核心设计理念**：
- **LLM作为导演**：LLM根据当前状态和隐藏的触发条件，动态决定事件触发和场景转换
- **事件驱动**：以事件为核心，驱动场景转换和人物状态变化
- **不确定性**：不预设明确的转换路径，保持剧情的灵活性和不可预测性
- **表里分离**：事件触发条件以"里"（隐藏）形式存在，对玩家不可见

---

## 二、系统设计

### 2.1 架构概览

```
剧本系统
├── 故事总览 (STORY_OVERVIEW.md)
│   ├── 剧情主线（整体方向，不预设路径）
│   ├── 场景池（所有可用场景，定义连接关系）
│   ├── 核心事件（重要剧情事件，不预设触发时机）
│   └── 导演指引（LLM如何作为导演推进剧情）
│
├── 场景剧本 (scenarios/)
│   ├── {scene_id}.md
│   │   ├── 场景描述（表：玩家可见）
│   │   ├── 场景状态（表：玩家可见）
│   │   ├── 潜在事件列表（里：LLM可见）
│   │   │   ├── 事件触发条件（里：隐藏条件）
│   │   │   ├── 事件描述模板
│   │   │   └── 事件影响（场景/角色状态变化）
│   │   └── 导演提示（里：LLM如何推进剧情）
│
└── 角色剧本 (characters/)
    ├── {character_id}_script.json
    │   ├── 背景故事扩展
    │   ├── 剧情关联（与哪些场景/事件相关）
    │   ├── 角色弧线（角色成长路径）
    │   └── 关键对话/行为模板
```

**关键设计**：
- **场景分级**：一级场景（主场景）和二级场景（房间），房间属于某个主场景
- **网状连接**：场景之间定义连接关系（哪些场景可以互相到达），但不预设具体转换路径
- **房间系统**：主场景可以包含多个房间，房间之间也可以有连接关系
- **事件驱动**：所有场景转换和状态变化都由事件触发
- **表里分离**：事件触发条件在"里"部分，对玩家隐藏
- **导演模式**：LLM作为导演，根据隐藏条件和当前状态，从可连接的场景中选择目标场景
- **怪物绑定**：怪物既可以与一级场景绑定，也可以与二级场景（房间）绑定

### 2.2 三层结构详细设计

#### 2.2.1 故事总览层 (STORY_OVERVIEW.md)

**位置**：`characters/{theme}/STORY_OVERVIEW.md`

**内容结构**：
```markdown
# 故事总览

## 剧情主线
- 主线描述：整体故事方向，但不预设具体路径
- 核心冲突：主要矛盾和张力来源
- 最终目标：故事的最终目标（可选，可动态调整）

## 场景池（网状连接关系，支持分级）

### 场景分级说明
- **一级场景（主场景）**：独立的主要场景，如"冒险者公会大厅"、"魔王城"
- **二级场景（房间）**：属于某个主场景的子场景，如"魔王城的大厅"、"魔王城的宝库"
- **房间归属**：每个房间必须属于一个主场景
- **怪物绑定**：怪物可以绑定到主场景（在该场景的任意房间都可能出现），也可以绑定到特定房间（只在该房间出现）

### 一级场景列表（主场景）
- scene_001: 冒险者公会大厅（起始场景）
- scene_002: 前往遗迹的森林小径
- scene_003: 遗迹入口
- scene_004: 森林中的遭遇战
- scene_005: 遗迹内部
- scene_006: 魔王城（最终场景）
- ...

### 二级场景列表（房间）
#### scene_006 (魔王城) 的房间
- room_006_001: 魔王城入口大厅
- room_006_002: 魔王城走廊
- room_006_003: 魔王城宝库
- room_006_004: 魔王城王座室
- room_006_005: 魔王城地下监牢
- ...

#### scene_005 (遗迹内部) 的房间（可选）
- room_005_001: 遗迹前厅
- room_005_002: 遗迹主室
- room_005_003: 遗迹密室
- ...

### 场景连接网络（网状结构，支持分级）

#### 一级场景之间的连接
定义哪些主场景之间可以互相到达：

```
scene_001 (公会大厅)
  ├─> scene_002 (森林小径) [可通过事件：接受任务]
  └─> scene_001 (自身) [可通过事件：停留、休息]

scene_002 (森林小径)
  ├─> scene_001 (公会大厅) [可通过事件：撤退、返回]
  ├─> scene_003 (遗迹入口) [可通过事件：到达目的地]
  ├─> scene_004 (遭遇战) [可通过事件：触发战斗]
  └─> scene_002 (自身) [可通过事件：探索、停留]

scene_003 (遗迹入口)
  ├─> scene_002 (森林小径) [可通过事件：撤退]
  ├─> scene_005 (遗迹内部) [可通过事件：进入遗迹]
  └─> scene_003 (自身) [可通过事件：探索入口]

scene_004 (遭遇战)
  ├─> scene_002 (森林小径) [可通过事件：战斗结束、继续前进]
  ├─> scene_001 (公会大厅) [可通过事件：战败撤退]
  └─> scene_004 (自身) [可通过事件：战斗进行中]

scene_005 (遗迹内部)
  ├─> scene_003 (遗迹入口) [可通过事件：退出遗迹]
  ├─> scene_006 (魔王城) [可通过事件：发现传送门] [需要前置：完成遗迹探索]
  └─> scene_005 (自身) [可通过事件：探索内部]

scene_006 (魔王城)
  ├─> scene_005 (遗迹内部) [可通过事件：返回]
  └─> scene_006 (自身) [可通过事件：进入魔王城]
```

#### 房间之间的连接（二级场景）
定义房间之间的连接关系，房间只能在同一主场景内或通过主场景转换：

```
scene_006 (魔王城) 的房间连接：
  room_006_001 (入口大厅)
    ├─> room_006_002 (走廊) [可通过事件：进入走廊]
    └─> scene_005 (遗迹内部) [可通过事件：退出魔王城]

  room_006_002 (走廊)
    ├─> room_006_001 (入口大厅) [可通过事件：返回入口]
    ├─> room_006_003 (宝库) [可通过事件：进入宝库]
    ├─> room_006_004 (王座室) [可通过事件：前往王座室] [需要前置：击败守卫]
    └─> room_006_005 (地下监牢) [可通过事件：进入监牢]

  room_006_003 (宝库)
    ├─> room_006_002 (走廊) [可通过事件：返回走廊]
    └─> room_006_003 (自身) [可通过事件：探索宝库]

  room_006_004 (王座室)
    ├─> room_006_002 (走廊) [可通过事件：返回走廊]
    └─> room_006_004 (自身) [可通过事件：最终战斗]

  room_006_005 (地下监牢)
    ├─> room_006_002 (走廊) [可通过事件：返回走廊]
    └─> room_006_005 (自身) [可通过事件：探索监牢]
```

**连接关系说明**：
- **一级场景连接**：主场景之间的连接关系
- **房间连接**：房间之间的连接关系（通常在同一主场景内）
- **跨级连接**：房间可以直接连接到其他主场景（如room_006_001 → scene_005）
- **双向连接**：大部分场景可以互相到达
- **单向连接**：某些场景只能单向到达（需要前置条件）
- **事件驱动**：场景转换必须由事件触发，不能直接跳转
- **前置条件**：某些连接需要满足特定条件（如完成某个任务、达到某个状态）
- **LLM选择**：当事件触发时，LLM从当前场景/房间的可连接目标中选择

**注意**：
- 场景连接关系定义了"可以到达哪些场景"，但不规定"必须到达哪个场景"
- LLM作为导演，根据事件和剧情需要，从可连接的场景中选择合适的目标
- 这样可以避免"新手村直达魔王城"等不合理的情况，同时保持灵活性

## 核心事件（重要剧情点，不预设触发时机）
- 事件1：接受任务（可能在scene_001触发）
- 事件2：首次遭遇魔物（可能在scene_002或scene_004触发）
- 事件3：进入遗迹（可能在scene_003触发）
- ...

**注意**：这些是重要的剧情节点，但触发时机由LLM根据当前状态和隐藏条件动态决定。

## 导演指引（LLM如何推进剧情）
作为导演，你应该：
1. **观察当前状态**：场景、角色状态、玩家行为
2. **评估隐藏条件**：检查场景剧本中的事件触发条件（里部分）
3. **动态决策**：根据剧情需要和不确定性，决定是否触发事件
4. **推进剧情**：通过事件驱动场景转换和状态变化
5. **保持不确定性**：不要机械地触发事件，保持剧情的自然流动和意外性

**原则**：
- 事件触发应该自然、符合剧情逻辑
- 可以延迟或提前触发事件，增加不确定性
- 场景转换应该由事件驱动，从可连接的场景中选择目标
- 必须遵守场景连接网络，不能跳转到未连接的场景
- 保持玩家体验的连贯性和沉浸感
```

#### 2.2.2 场景剧本层 (scenarios/)

**位置**：
- 一级场景：`characters/{theme}/scenarios/{scene_id}.md`
- 二级场景（房间）：`characters/{theme}/scenarios/{scene_id}/rooms/{room_id}.md`

**一级场景内容结构**：
```markdown
# 场景剧本：{场景名称}

## 场景ID
{scene_id}

## 场景类型
一级场景（主场景）

## 表（玩家可见）

### 场景描述
详细的环境描述、氛围、关键元素（玩家可见）

### 场景状态
- 时间：{time}
- 地点：{location}
- 当前状况：{current_situation}
- 可见元素：{visible_elements}

### 包含的房间（如果适用）
- room_{scene_id}_001: {房间名称}
- room_{scene_id}_002: {房间名称}
- ...

## 里（LLM推演用，隐藏）

### 潜在事件列表（隐藏触发条件）

#### 事件1：{event_name}
- **触发条件（隐藏）**：
  - 时间条件：{time_condition}（如：在场景中停留超过3个步骤）
  - 状态条件：{state_condition}（如：角色HP低于50%）
  - 行为条件：{behavior_condition}（如：玩家指令包含"探索"、"调查"等）
  - 随机因素：{random_factor}（如：30%概率）
  - 剧情需求：{plot_need}（如：需要推进剧情时）
  
- **事件描述模板**：{description_template}
  - 用于LLM生成事件描述，保持风格一致

- **事件影响（隐藏）**：
  - 场景状态变化：{scene_change}
  - 角色状态变化：{character_changes}
  - 可能触发的场景转换：{possible_scenes}（LLM决定）
  - 后续事件解锁：{unlocked_events}

- **导演提示**：
  - 何时触发：{when_to_trigger}
  - 如何触发：{how_to_trigger}
  - 注意事项：{notes}

#### 事件2：{event_name}
...

### 潜在怪物列表（隐藏，与场景/房间绑定）

#### 怪物1：{monster_name}
- **绑定类型**：场景绑定 / 房间绑定
  - 场景绑定：在该场景的任意房间都可能出现
  - 房间绑定：只在特定房间出现（需要指定room_id）

- **绑定目标**：
  - 如果场景绑定：{scene_id}（当前场景）
  - 如果房间绑定：{room_id}（特定房间）

- **怪物信息（隐藏）**：
  - 名称：{name}
  - 类型：{type}（如：魔物、野兽、不死生物等）
  - 等级/难度：{level/difficulty}
  - 描述：{description}（外观、行为特征等）
  - 属性：{attributes}
    - HP：{hp}
    - 攻击力：{attack}
    - 防御力：{defense}
    - 特殊能力：{abilities}
  
- **出现条件（隐藏）**：
  - 时间条件：{time_condition}（如：夜晚、特定时间段）
  - 位置条件：{location_condition}（如：深入森林、特定区域、特定房间）
  - 行为条件：{behavior_condition}（如：玩家指令包含"探索深处"、"调查异常"等）
  - 状态条件：{state_condition}（如：角色HP低于某个值、队伍疲劳等）
  - 随机因素：{random_factor}（如：40%概率）
  - 剧情需求：{plot_need}（如：需要战斗推进剧情时）
  - 前置事件：{prerequisite_events}（如：需要先触发某个事件）

- **战斗事件描述模板**：{battle_description_template}
  - 用于LLM生成遭遇怪物的描述，保持风格一致

- **战斗影响（隐藏）**：
  - 胜利后：{on_victory}
    - 经验/奖励：{rewards}
    - 场景状态变化：{scene_changes}
    - 可能解锁的事件：{unlocked_events}
    - 可能触发的场景转换：{possible_scenes/rooms}
  - 失败后：{on_defeat}
    - 后果：{consequences}
    - 场景状态变化：{scene_changes}
    - 可能触发的场景转换：{possible_scenes/rooms}（如：撤退到安全场景）

- **导演提示**：
  - 何时出现：{when_to_appear}
  - 如何描述：{how_to_describe}
  - 战斗节奏：{battle_pacing}
  - 注意事项：{notes}

#### 怪物2：{monster_name}
...

**潜在怪物说明**：
- 怪物可以绑定到一级场景（在该场景的任意房间都可能出现）
- 怪物也可以绑定到二级场景/房间（只在特定房间出现）
- 出现条件在"里"部分，对玩家隐藏
- LLM作为导演，根据隐藏条件决定是否让怪物出现
- 怪物出现会触发战斗事件，影响场景和角色状态

### 导演指引（隐藏）
作为导演，在这个场景中：
1. **观察点**：{observation_points}
2. **推进时机**：{timing_hints}
3. **不确定性**：{uncertainty_notes}
4. **剧情方向**：{plot_direction}（建议，非强制）

### 场景转换可能性（隐藏）
**注意**：LLM根据事件从可连接的场景/房间中选择目标

可连接的目标（从场景网络定义）：
- 一级场景：
  - scene_002: {description}（可能由事件X触发）
  - scene_003: {description}（可能由事件Y触发）
  - ...
- 二级场景（房间，如果当前场景有房间）：
  - room_{scene_id}_001: {description}（可能由事件Z触发）
  - room_{scene_id}_002: {description}（可能由事件W触发）
  - ...

**转换原则**：
- 场景转换必须由事件驱动
- 只能转换到场景网络中定义的连接场景/房间
- 必须满足前置条件（如果有）
- 转换应该自然、符合剧情逻辑
- LLM从可连接目标中选择最合适的目标
- 可以创造意外和不确定性，但必须在连接范围内
```

**二级场景（房间）内容结构**：
```markdown
# 房间剧本：{房间名称}

## 房间ID
{room_id}

## 所属场景
{parent_scene_id}（一级场景）

## 场景类型
二级场景（房间）

## 表（玩家可见）

### 房间描述
详细的环境描述、氛围、关键元素（玩家可见）

### 房间状态
- 时间：{time}（继承自主场景或独立）
- 位置：{location}（房间的具体位置）
- 当前状况：{current_situation}
- 可见元素：{visible_elements}

## 里（LLM推演用，隐藏）

### 潜在事件列表（隐藏触发条件）
（与一级场景格式相同）

### 潜在怪物列表（隐藏，与房间绑定）
（与一级场景格式相同，但绑定类型为"房间绑定"）

### 房间转换可能性（隐藏）
可连接的目标：
- 同一主场景的其他房间：
  - room_{scene_id}_002: {description}
  - room_{scene_id}_003: {description}
  - ...
- 其他主场景：
  - scene_XXX: {description}（如果房间网络允许）
- 返回主场景：
  - {parent_scene_id}: {description}

### 导演指引（隐藏）
（与一级场景格式相同）
```

#### 2.2.3 角色剧本层 (characters/)

**位置**：`characters/{theme}/{character_id}_script.json` 或扩展现有JSON

**内容结构**：
```json
{
  "character_id": "hero",
  "script_extension": {
    "extended_background": "更详细的背景故事，包括与剧情相关的部分...",
    "plot_connections": [
      {
        "scene_id": "scene_002",
        "role": "关键角色",
        "relevance": "艾伦是队伍的领导者，在森林小径场景中负责指挥"
      }
    ],
    "character_arc": {
      "current_stage": "初始阶段",
      "growth_path": [
        "阶段1：新手冒险者",
        "阶段2：经历首次战斗",
        "阶段3：成为可靠队长"
      ],
      "key_moments": [
        {
          "scene_id": "scene_004",
          "moment": "首次遭遇强敌时的反应"
        }
      ]
    },
    "key_behaviors": [
      {
        "trigger": "队伍遇到危险",
        "behavior": "立即组织防御，保护队友"
      }
    ],
    "dialogue_templates": [
      {
        "situation": "战斗前",
        "template": "大家保持队形，我来掩护！"
      }
    ]
  }
}
```

**注意**：潜在怪物不在角色剧本层，而是在场景剧本层中定义，因为怪物与场景绑定。

---

## 三、文件结构

### 3.1 新增文件结构

```
characters/
└── {theme}/
    ├── STORY_OVERVIEW.md          # 故事总览（新增）
    ├── SCENE.md                   # 当前场景（现有，保持不变）
    ├── CHARACTER_ATTRIBUTES.md    # 角色属性说明（现有）
    │
    ├── scenarios/                 # 场景剧本目录（新增）
    │   ├── scene_001_公会大厅.md  # 一级场景
    │   ├── scene_002_森林小径.md
    │   ├── scene_003_遗迹入口.md
    │   ├── scene_006_魔王城.md    # 一级场景（包含房间）
    │   │   └── rooms/             # 二级场景（房间）目录
    │   │       ├── room_006_001_入口大厅.md
    │   │       ├── room_006_002_走廊.md
    │   │       ├── room_006_003_宝库.md
    │   │       ├── room_006_004_王座室.md
    │   │       └── room_006_005_地下监牢.md
    │   └── ...
    │
    └── {character_id}.json        # 角色基础信息（现有）
    └── {character_id}_script.json # 角色剧本扩展（新增，可选）
```

### 3.2 系统迁移策略

- **全面转向剧本系统**：完全抛弃现有机制，不再使用现有的 `SCENE.md` 和角色 JSON 文件
- **重新设计存档机制**：基于场景ID和房间ID的存档系统，不再依赖现有的存档文件结构
- **场景映射**：存档目录中存储 `SCENE_ID.txt` 和 `ROOM_ID.txt`，通过场景ID/房间ID加载对应剧本
- **场景状态**：场景状态从场景剧本的"表"部分生成，动态更新
- **角色状态**：角色状态继续使用 JSON 格式，但结构与剧本系统集成
- **场景分级**：支持一级场景（主场景）和二级场景（房间）的分级管理
- **存档迁移**：现有存档需要迁移到新系统，或重新开始游戏

---

## 四、实现步骤

### 阶段1：数据结构与文件格式定义

#### 1.1 创建剧本管理器服务
- **文件**：`services/script_manager.py`
- **功能**：
  - 加载故事总览
  - 加载一级场景剧本
  - 加载二级场景（房间）剧本
  - 场景分级管理（场景和房间的关系）
  - 场景/房间转换逻辑
  - 事件触发判断
  - 潜在怪物管理（与场景/房间绑定）

#### 1.2 定义数据模型
- 故事总览模型
- 一级场景剧本模型（包含潜在事件和潜在怪物）
- 二级场景（房间）剧本模型（包含潜在事件和潜在怪物）
- 角色剧本扩展模型
- 潜在怪物模型（支持场景绑定和房间绑定）

### 阶段2：存档系统重新设计

#### 2.1 重新设计存档结构
- **抛弃现有存档文件**：不再使用 `SCENE.md` 作为场景状态文件
- **基于场景ID的存档**：
  - `SCENE_ID.txt`：存储当前一级场景ID
  - `ROOM_ID.txt`：存储当前二级场景（房间）ID（可选，如果在一级场景中则为空）
  - `SCENE_STATE.json`：存储场景状态变化（动态生成，从场景剧本的"表"部分更新）
- **角色状态**：继续使用 `{character_id}.json`，但结构与剧本系统集成
- **对话历史**：继续使用 `HISTORY.json`

#### 2.2 场景状态生成机制
- 从场景剧本的"表"部分生成初始场景状态
- 根据事件和状态变化动态更新场景状态
- 场景状态存储在 `SCENE_STATE.json` 中，用于记录动态变化
- 场景描述从场景剧本加载，状态从存档加载

#### 2.3 存档迁移工具（可选）
- 创建迁移工具，将现有存档转换为新格式
- 或提供"重新开始"选项，使用新系统创建新存档

### 阶段3：剧本加载与集成

#### 3.1 修改 EnvironmentManager
- 集成 `ScriptManager`
- **完全基于剧本系统**：不再加载现有的 `SCENE.md`，改为加载场景剧本
- 在加载场景时，从场景剧本的"表"部分生成场景描述
- 如果当前在房间中，加载房间剧本（二级场景）
- 提供场景/房间转换建议
- 支持场景分级的状态管理

#### 3.2 修改 MultiAgentCoordinator
- 添加导演评估阶段（在处理指令前）
- LLM作为导演评估当前状态和隐藏条件（考虑场景和房间）
- LLM动态决定事件触发和场景/房间转换
- 事件驱动场景/房间转换和状态更新
- 支持场景分级的状态跟踪（当前场景ID和房间ID）
- **完全基于剧本系统**：不再使用现有的场景加载机制

#### 3.3 修改 Agent
- 加载角色剧本扩展
- 在生成响应时参考角色的剧情关联和关键行为

### 阶段4：剧情推进机制

#### 3.1 LLM导演评估系统
- 创建导演评估服务（DirectorEvaluator）
- 在每个步骤开始时，LLM评估当前状态和隐藏条件（考虑场景和房间）
- LLM决定是否触发事件、触发哪个事件
- LLM决定是否转换场景/房间、转换到哪个目标

#### 3.2 事件触发系统（事件驱动）
- 加载场景/房间剧本中的潜在事件列表（里部分）
- 将事件触发条件（隐藏）传递给LLM导演
- LLM根据隐藏条件和剧情需要，动态决定是否触发
- 事件触发后，更新场景/房间状态（表部分）和角色状态
- 事件可能驱动场景/房间转换（LLM决定）

#### 3.3 潜在怪物系统（与场景/房间绑定）
- 加载场景/房间剧本中的潜在怪物列表（里部分）
- 将怪物出现条件（隐藏）传递给LLM导演
- 支持场景绑定（在该场景的任意房间都可能出现）和房间绑定（只在特定房间出现）
- LLM根据隐藏条件和剧情需要，动态决定是否让怪物出现
- 怪物出现触发战斗事件，更新场景/房间状态和角色状态
- 战斗结果影响后续剧情和场景/房间转换

#### 3.4 场景/房间转换系统（事件驱动）
- 不预设场景转换路径
- 场景/房间转换由事件触发，LLM动态决定目标
- 从场景网络中选择合适的目标（一级场景或二级场景/房间）
- 支持房间之间的转换（同一主场景内）
- 支持房间到其他主场景的转换（如果网络允许）
- 更新存档中的场景ID、房间ID和状态

### 阶段5：示例剧本创建

#### 5.1 为 adventure_party 主题创建完整剧本
- `STORY_OVERVIEW.md`（包含场景池和连接网络）
- 所有一级场景剧本（至少3-5个）
- 关键场景的房间剧本（如魔王城的房间）
- 角色剧本扩展（可选）

#### 5.2 测试与优化
- 测试场景/房间转换
- 测试事件触发
- 测试怪物出现
- 测试剧情推进效果
- 测试存档系统

---

## 五、核心功能实现

### 5.1 ScriptManager 核心方法

```python
class ScriptManager:
    def load_story_overview(self, theme: str) -> Dict
    def load_scene_script(self, theme: str, scene_id: str) -> Dict  # 加载一级场景
    def load_room_script(self, theme: str, room_id: str) -> Dict  # 加载二级场景（房间）
    def get_scene_pool(self, theme: str) -> List[Dict]  # 获取场景池（一级场景）
    def get_rooms_for_scene(self, theme: str, scene_id: str) -> List[Dict]  # 获取场景的所有房间
    def get_parent_scene(self, theme: str, room_id: str) -> str  # 获取房间所属的主场景
    def get_connected_scenes(self, theme: str, scene_id: str, room_id: Optional[str] = None) -> List[Dict]  # 获取可连接的目标（场景或房间）
    def check_scene_connection(self, theme: str, from_id: str, to_id: str, from_type: str = "scene", to_type: str = "scene") -> bool  # 检查是否连接（支持场景和房间）
    def check_connection_conditions(self, theme: str, from_id: str, to_id: str, context: Dict, from_type: str = "scene", to_type: str = "scene") -> Tuple[bool, str]  # 检查连接前置条件
    def get_potential_events(self, theme: str, scene_id: str, room_id: Optional[str] = None) -> List[Dict]  # 获取潜在事件（里部分）
    def get_event_trigger_conditions(self, theme: str, scene_id: str, event_id: str, room_id: Optional[str] = None) -> Dict  # 获取事件触发条件（隐藏）
    def get_potential_monsters(self, theme: str, scene_id: str, room_id: Optional[str] = None) -> List[Dict]  # 获取潜在怪物（里部分，支持场景和房间绑定）
    def get_monster_appearance_conditions(self, theme: str, scene_id: str, monster_id: str, room_id: Optional[str] = None) -> Dict  # 获取怪物出现条件（隐藏）
    def load_character_script(self, theme: str, character_id: str) -> Dict

class DirectorEvaluator:
    """LLM导演评估器"""
    def evaluate_as_director(self, context: Dict) -> Dict
        # LLM作为导演评估当前状态，决定事件触发、怪物出现和场景/房间转换
        # 返回：{
        #   "trigger_event": event_id or None,
        #   "event_description": str,
        #   "appear_monster": monster_id or None,  # 是否让怪物出现
        #   "monster_description": str,  # 怪物出现描述
        #   "transition_target": target_id or None,  # 目标场景或房间ID
        #   "transition_type": "scene" or "room",  # 转换类型
        #   "reasoning": str  # 导演的决策理由（隐藏）
        # }
        # 注意：transition_target 必须是场景网络中定义的连接目标
```

### 5.2 事件驱动流程（核心）

```
1. 玩家输入指令
2. LLM作为导演评估当前状态：
   - 加载当前场景的潜在事件列表（里部分）
   - 评估每个事件的触发条件
   - 考虑剧情需要和不确定性
3. LLM决定是否触发事件：
   - 如果触发：生成事件描述，更新状态，可能触发场景转换
   - 如果不触发：正常处理玩家指令
4. 如果事件触发，LLM决定场景转换：
   - 根据事件影响和剧情需要
   - 动态选择目标场景（从场景池中选择）
   - 更新存档中的场景ID
5. 继续处理指令（可能在新场景中）
```

### 5.3 LLM导演决策流程

```
1. 每个步骤开始时：
   - ScriptManager.get_potential_events() 获取当前场景的潜在事件（里部分）
   - 将事件触发条件（隐藏）传递给LLM
   
2. LLM作为导演评估：
   - 当前场景状态
   - 角色状态
   - 玩家行为
   - 剧情需要
   - 事件触发条件（隐藏）
   - 潜在怪物出现条件（隐藏，与场景绑定）
   
3. LLM动态决策：
   - 是否触发事件（根据隐藏条件和剧情需要）
   - 触发哪个事件（可能有多个候选）
   - 如何描述事件（使用事件描述模板）
   - 是否让怪物出现（根据隐藏条件和剧情需要）
   - 出现哪个怪物（可能有多个候选，与场景绑定）
   - 如何描述怪物出现（使用怪物描述模板）
   - 是否转换场景（由事件驱动）
   - 转换到哪个场景（从场景网络中可连接的场景中选择）
   - 验证场景连接：确保目标场景在连接网络中，且满足前置条件
   
4. 执行决策：
   - 生成事件描述（玩家可见）
   - 如果怪物出现，生成怪物出现描述（玩家可见）
   - 如果触发战斗，处理战斗事件
   - 更新场景状态（表部分）
   - 更新角色状态
   - 可能触发场景转换
   - 可能解锁后续事件
```

### 5.4 表里分离的实现

- **表（玩家可见）**：场景描述、当前状态、事件描述（触发后）、怪物出现描述（出现后）
- **里（LLM可见）**：事件触发条件、潜在怪物出现条件（与场景绑定）、导演指引、场景转换可能性、剧情推进提示
- **LLM作为导演**：根据"里"信息动态决策，生成"表"内容

### 5.5 潜在怪物系统流程

```
1. 加载场景剧本时，获取潜在怪物列表（里部分）
2. 将怪物出现条件（隐藏）传递给LLM导演
3. LLM评估是否让怪物出现：
   - 检查出现条件（时间、位置、行为、状态、随机因素、剧情需求）
   - 考虑剧情需要和不确定性
4. 如果决定让怪物出现：
   - 生成怪物出现描述（玩家可见）
   - 触发战斗事件
   - 处理战斗结果
   - 更新场景状态和角色状态
   - 可能影响后续剧情和场景转换
```

---

## 六、LLM Prompt 增强

### 6.1 LLM导演模式的Prompt设计

在 `MultiAgentCoordinator` 中，添加导演评估步骤：

```python
# 导演评估阶段（在处理指令前）
current_scene_id = get_current_scene_id(theme, save_step)
current_room_id = get_current_room_id(theme, save_step)  # 可能为None（如果在一级场景）

# 获取可连接的目标（场景或房间）
connected_targets = script_manager.get_connected_scenes(theme, current_scene_id, current_room_id)

# 获取潜在事件和怪物（考虑当前场景和房间）
potential_events = script_manager.get_potential_events(theme, current_scene_id, current_room_id)
potential_monsters = script_manager.get_potential_monsters(theme, current_scene_id, current_room_id)

director_context = {
    "current_scene": current_scene_id,
    "current_room": current_room_id,  # 可能为None
    "scene_script": script_manager.load_scene_script(theme, current_scene_id),
    "room_script": script_manager.load_room_script(theme, current_room_id) if current_room_id else None,
    "potential_events": potential_events,
    "potential_monsters": potential_monsters,  # 潜在怪物（与场景/房间绑定）
    "connected_targets": connected_targets,  # 可连接的目标列表（场景或房间）
    "scene_network": script_manager.get_scene_network(theme),  # 完整的场景连接网络
    "character_states": current_character_states,
    "player_instruction": instruction,
    "story_overview": script_manager.load_story_overview(theme)
}

# LLM作为导演评估
director_decision = llm_director_evaluate(director_context)
# 返回：是否触发事件、触发哪个事件、是否让怪物出现、是否转换场景/房间等

# 验证场景/房间转换
if director_decision.get("transition_target"):
    target_id = director_decision["transition_target"]
    transition_type = director_decision.get("transition_type", "scene")
    
    # 确定当前类型
    from_type = "room" if current_room_id else "scene"
    from_id = current_room_id if current_room_id else current_scene_id
    
    # 验证目标是否在可连接列表中
    if not script_manager.check_scene_connection(theme, from_id, target_id, from_type, transition_type):
        raise ValueError(f"目标 {target_id} ({transition_type}) 不在可连接列表中")
    
    # 检查前置条件
    can_connect, reason = script_manager.check_connection_conditions(
        theme, from_id, target_id, context, from_type, transition_type
    )
    if not can_connect:
        # 如果前置条件不满足，LLM需要重新选择或等待
        director_decision["transition_target"] = None
        director_decision["blocking_reason"] = reason

# 处理怪物出现
if director_decision.get("appear_monster"):
    monster_id = director_decision["appear_monster"]
    # 验证怪物是否属于当前场景/房间
    monsters = script_manager.get_potential_monsters(theme, current_scene_id, current_room_id)
    if not any(m.get("id") == monster_id for m in monsters):
        raise ValueError(f"怪物 {monster_id} 不属于当前场景/房间")
    # 触发战斗事件
    battle_event = trigger_battle_event(monster_id, director_decision["monster_description"])
```

**导演Prompt模板**：
```
你是一个剧情导演，负责推进游戏剧情。

【当前状态】
- 场景：{current_scene}
- 角色状态：{character_states}
- 玩家指令：{instruction}

【隐藏信息（仅你可见）】
- 潜在事件列表：{potential_events}（包含触发条件）
- 潜在怪物列表：{potential_monsters}（与场景绑定，包含出现条件）
- 可连接场景：{connected_scenes}（从场景网络定义，只能从这些场景中选择）
- 场景连接网络：{scene_network}（哪些场景可以互相到达）
- 剧情需要：{plot_needs}

【你的任务】
1. 评估是否应该触发事件（根据隐藏的触发条件和剧情需要）
2. 评估是否应该让怪物出现（根据隐藏的出现条件和剧情需要）
3. 如果触发，选择合适的事件并生成描述
4. 如果怪物出现，选择合适的怪物并生成遭遇描述
5. 决定是否转换场景（由事件驱动）
6. 如果转换场景，必须从可连接场景中选择目标场景
7. 保持剧情的不确定性和自然流动

【原则】
- 不要机械地触发事件，要自然、符合剧情逻辑
- 不要机械地让怪物出现，要自然、符合剧情逻辑
- 可以延迟或提前触发，增加不确定性
- 场景转换必须由事件驱动
- **必须遵守场景连接网络**：只能转换到已定义的连接场景，不能跳转到未连接的场景
- 怪物与场景绑定，只在对应场景中可能出现
- 从可连接场景中选择最合适的目标，保持玩家体验的连贯性
```

### 6.2 场景加载时的Prompt增强

在加载场景时，除了现有的 `SCENE.md`（表部分），还加载：
- 当前场景/房间剧本的潜在事件列表（里部分，隐藏触发条件）
- 当前场景/房间剧本的潜在怪物列表（里部分，隐藏出现条件，与场景/房间绑定）
- 导演指引（里部分）
- 可连接目标列表（从场景网络定义，里部分，包括场景和房间）
- 场景连接网络（完整的连接关系，里部分，包括房间连接）
- 如果当前在房间中，加载房间所属的主场景信息

### 6.3 Agent处理指令时的Prompt增强

在 `Agent.process_instruction()` 中，添加：
- 角色剧本扩展信息
- 角色在当前场景中的剧情关联
- 角色的关键行为模板
- 如果事件已触发，事件对角色的影响

### 6.4 事件和怪物触发后的Prompt增强

当事件触发后：
- 生成事件描述（玩家可见，表部分）
- 更新场景状态（表部分）
- 更新角色状态
- 如果触发场景转换，加载新场景的剧本

当怪物出现后：
- 生成怪物出现描述（玩家可见，表部分）
- 触发战斗事件
- 更新场景状态（表部分）
- 更新角色状态（战斗结果）
- 战斗结果可能影响后续剧情和场景转换

---

## 七、配置与扩展

### 7.1 配置文件

在 `config.py` 中添加：
```python
# 剧本系统配置
SCRIPT_SYSTEM_ENABLED = os.getenv('SCRIPT_SYSTEM_ENABLED', 'true').lower() == 'true'
SCENARIOS_DIR = 'scenarios'  # 场景剧本目录名
```

### 7.2 场景ID映射（新存档系统）

在存档目录中创建文件存储当前场景和房间信息：
- `SCENE_ID.txt`：存储当前一级场景ID
  ```
  scene_001
  ```
- `ROOM_ID.txt`：存储当前二级场景（房间）ID（如果当前在房间中，否则为空或不存在）
  ```
  room_006_001
  ```
- `SCENE_STATE.json`：存储场景状态变化（动态生成）
  ```json
  {
    "scene_id": "scene_001",
    "room_id": null,
    "state_changes": {
      "time": "黎明（具体时刻：约6:00）",
      "location": {...},
      "current_narrative": "...",
      ...
    }
  }
  ```

**注意**：
- **完全基于剧本系统**：不再使用 `SCENE.md`，场景描述从场景剧本加载
- 场景ID用于加载对应的一级场景剧本
- 房间ID用于加载对应的二级场景（房间）剧本
- 场景状态从场景剧本的"表"部分生成，动态更新存储在 `SCENE_STATE.json`
- 场景/房间转换由LLM导演根据事件动态决定
- 如果当前在一级场景中，`ROOM_ID.txt` 为空或不存在

### 7.3 扩展性

- 支持多分支剧情
- 支持条件触发的事件链
- 支持角色特定的场景解锁
- 支持动态场景生成（基于模板）

---

## 八、测试计划

### 8.1 单元测试
- ScriptManager 的各个方法
- 场景转换逻辑
- 事件触发评估

### 8.2 集成测试
- 完整的场景/房间转换流程
- 事件触发与状态更新
- 怪物出现与战斗
- 剧情推进效果
- 新存档系统的读写

### 8.3 用户测试
- 创建完整示例剧本
- 实际游戏测试（使用新系统）
- 存档迁移测试（如果有迁移工具）
- 收集反馈并优化

---

## 九、开发优先级

### 高优先级（第一阶段）
1. ✅ ScriptManager 基础框架
2. ✅ 故事总览文件格式定义（场景池，网状连接关系）
3. ✅ 场景剧本文件格式定义（表里分离，事件触发条件在里部分）
4. ✅ 场景连接网络解析和验证
5. ✅ 新存档系统设计（基于场景ID和房间ID）
6. ✅ DirectorEvaluator LLM导演评估器

### 中优先级（第二阶段）
7. ⏳ 事件触发系统（LLM导演动态决策）
8. ⏳ 事件驱动的场景/房间转换系统
9. ⏳ 场景状态生成机制（从剧本生成）
10. ⏳ 角色剧本扩展
11. ⏳ 存档迁移工具（可选）

### 低优先级（第三阶段）
8. ⏸️ 事件链和连锁反应
9. ⏸️ 动态场景生成
10. ⏸️ 高级导演决策优化

---

## 十、预期效果

### 10.1 解决的问题
- ✅ LLM作为导演能够主动推进剧情，引入不确定性
- ✅ 场景转换由事件驱动，更加自然和动态
- ✅ 场景分级系统支持复杂场景结构（如魔王城包含多个房间）
- ✅ 场景连接网络避免不合理跳转（如新手村直达魔王城）
- ✅ 房间系统提供更精细的场景管理（怪物可以绑定到房间）
- ✅ 事件触发时机由LLM根据隐藏条件动态决定，更加合理
- ✅ 角色行为更加符合剧情发展
- ✅ 保持剧情的灵活性和不可预测性，同时遵守合理的场景连接

### 10.2 提升的体验
- 剧情连贯性提升
- 游戏节奏更好控制
- 玩家体验更加流畅
- 支持更复杂的剧情设计

---

## 十一、注意事项

1. **全面转向剧本系统**：完全抛弃现有机制，不再使用 `SCENE.md` 和现有存档结构
2. **存档系统重构**：重新设计存档机制，基于场景ID和房间ID，场景状态从剧本生成
3. **灵活性**：剧本系统应该是指导性的，而非强制性的
4. **不确定性**：LLM作为导演，保持剧情的灵活性和不可预测性
5. **场景连接网络**：定义场景之间的连接关系，避免不合理跳转，但不预设具体路径
6. **表里分离**：事件触发条件在"里"部分，对玩家隐藏
7. **事件驱动**：所有场景转换和状态变化都由事件驱动
8. **连接验证**：场景转换时必须验证连接关系和前置条件
9. **场景分级**：支持一级场景和二级场景（房间）的分级管理
10. **可编辑性**：剧本文件应该是人类可读、可编辑的
11. **性能**：剧本加载不应显著影响响应速度
12. **扩展性**：设计时考虑未来可能的扩展需求
13. **存档迁移**：现有存档需要迁移到新系统，或提供"重新开始"选项

---

## 十二、后续优化方向

1. **可视化工具**：开发剧本编辑工具
2. **AI辅助生成**：使用LLM辅助生成场景剧本
3. **剧情分析**：分析玩家行为，优化剧情推进
4. **动态调整**：根据玩家选择动态调整剧情难度和方向

---

**文档版本**：v1.0  
**创建日期**：2024  
**最后更新**：2024

