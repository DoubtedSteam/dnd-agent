# 传递给LLM的信息说明

## 概述

本文档详细说明导演评估器（DirectorEvaluator）传递给LLM的所有信息。这些信息构成了LLM作为剧情导演进行决策的上下文。

## 信息结构

传递给LLM的信息通过一个详细的Prompt组织，包含以下部分：

1. 【当前场景状态】
2. 【当前时间信息】
3. 【当前事件状态】
4. 【玩家指令】
5. **【Agent实际响应】**（新增，最重要）
6. 【场景描述（玩家可见）】
7. 【角色状态】
8. 【当前场景下的可能事件（隐藏信息，仅你可见）】
9. 【潜在怪物列表（隐藏信息，仅你可见）】
10. 【可连接目标（隐藏信息，仅你可见）】
11. 【你的任务】
12. 【场景连接网络规则】
13. 【原则】
14. 【导演工作流程】
15. 【输出格式】

## 详细说明

### 1. 【当前场景状态】

**说明**：显示当前所在的场景和房间信息，以及场景状态变化。**注意：这是导演评估使用的信息，包含技术性标识符（场景ID、房间ID）。Agent不会看到这些ID信息。**

**数据来源**：
- `current_scene`：当前场景ID（如`"scene_001"`）- **仅导演评估可见**
- `current_room`：当前房间ID（如`"room_002_001"`），如果在一级场景中则为`null` - **仅导演评估可见**
- `scene_state`：场景状态字典，包含状态变化信息

**格式示例**：
```
场景ID: scene_001, 房间ID: null
状态变化: {"村民态度": "期待"}
```

**包含信息**：
- 场景ID和房间ID（**仅导演评估可见，Agent不会看到**）
- 场景状态变化（从`SCENE_STATE.json`读取）

**表里区分**：
- 这是导演评估的内部信息，包含技术性标识符
- Agent不会看到场景ID、房间ID等技术标识符
- Agent只能看到场景描述文本和玩家可见的状态信息

### 2. 【当前时间信息】

**说明**：显示当前游戏内时间和进入当前场景/房间的时间信息。

**数据来源**：
- `game_time`：游戏时间字典（从`GAME_TIME.json`读取）
- `enter_time`：进入当前场景/房间的时间（从`SCENE_STATE.json`的`state_changes.enter_time`读取）

**格式示例**：
```
当前游戏时间: 第1天 14:30
进入当前场景/房间时间: 120.5分钟前（游戏内时间）
在当前场景/房间停留时间: 5.2分钟（游戏内时间）
```

**包含信息**：
- 当前游戏内时间（格式：第X天 HH:MM）
- 进入当前场景/房间的时间（相对于游戏开始时间的分钟数）
- 在当前场景/房间的停留时间（当前时间 - 进入时间）

**用途**：
- 帮助LLM判断事件触发条件中的时间条件（如"在场景中停留超过5分钟"）
- 让LLM了解当前的时间状态，做出更合理的决策

### 3. 【当前事件状态】

**说明**：显示已触发的事件信息。

**数据来源**：
- `triggered_events`：已触发的事件ID列表（从`SCENE_STATE.json`读取）

**格式示例**：
```
已触发事件数: 1
已触发事件ID: event_001
```

**包含信息**：
- 已触发事件的数量
- 已触发事件ID列表

### 4. 【玩家指令】

**说明**：玩家当前输入的指令。

**数据来源**：
- `player_instruction`：玩家输入的指令文本

**格式示例**：
```
接受村民的委托，前往田野清剿魔物
```

**包含信息**：
- 玩家的原始指令文本

### 5. 【Agent实际响应】（新增，最重要）

**说明**：每个Agent对玩家指令的实际响应，包括响应文本、状态变化和属性变化。**这是导演评估的重要依据，所有决策都应该基于Agent的实际响应。**

**数据来源**：
- `agent_responses`：Agent响应列表，包含每个Agent的响应信息

**格式示例**：
```
【Agent实际响应】（这是智能体对玩家指令的实际响应，你应该基于这些响应来决定事件和场景变化）:

角色1: 勇者
  响应: 我接受了村民的委托，准备前往田野清剿魔物。我检查了装备，确保武器和防具都准备就绪。
  状态变化: {"任务状态": "已接受清剿任务", "目标地点": "田野"}
  属性变化: {}

角色2: 村民
  响应: 太好了！冒险者，我们的田野就在村庄的东边。请小心，那里的魔物很危险。
  状态变化: {"态度": "感激"}
  属性变化: {}
```

**包含信息**：
- 每个角色的名称
- 每个角色的实际响应文本（限制长度，通常前150-200字符）
- 每个角色的状态变化（state_changes）
- 每个角色的属性变化（attribute_changes）

**用途**：
- **决定是否触发事件**：如果Agent响应中提到了相关行为（如"接受任务"、"前往田野"等），应该考虑触发对应的事件
- **决定是否让怪物出现**：如果Agent响应中提到了战斗、遭遇、发现敌人等，应该考虑让怪物出现
- **决定是否转换场景**：如果Agent响应中明确表示移动、到达、进入某个地点，应该考虑场景转换
- **决定时间消耗**：根据Agent的实际行为（如探索、战斗、对话）来估算时间消耗
- **生成事件描述**：事件描述应该与Agent的实际响应相关，反映Agent的行为

**重要原则**：
- **所有决策都应该基于Agent的实际响应**，而不仅仅是玩家指令
- Agent的响应、状态变化和属性变化是导演评估的重要依据
- 如果Agent响应与玩家指令不一致，应该以Agent的实际响应为准

### 6. 【场景描述（玩家可见）】

**说明**：当前场景/房间的描述，这是玩家可以看到的信息。

**数据来源**：
- 如果当前在房间中：从`room_script`的`surface.description`获取
- 如果在一级场景中：从`scene_script`的`surface.description`获取

**格式示例**：
```
你站在一个宁静的村庄广场中央。阳光洒在石板路上，周围是几座朴素的木制房屋。村民们三三两两地走过，有的在交谈，有的在忙碌。广场的一角有一个公告板，上面贴着一些委托。
```

**包含信息**：
- 场景/房间的详细描述
- 环境氛围
- 可见元素

### 7. 【角色状态】

**数据来源**：
- `character_states`：角色状态字典，包含所有角色的属性信息

**格式示例**：
```json
{
  "勇者": {
    "hp": 100,
    "mp": 50,
    "level": 5
  }
}
```

**包含信息**：
- 所有角色的属性状态
- 从存档文件（`{character_id}.json`）读取

### 8. 【当前场景下的可能事件（隐藏信息，仅你可见）】

**说明**：当前场景/房间关联的所有潜在事件，包括核心事件和随机事件。

**数据来源**：
- `potential_events`：从`core_events.json`和`random_events.json`中筛选，根据`associated_scenes`字段匹配当前场景/房间

**格式示例**：
```
【核心事件】（可以转换状态和推进剧本阶段）:
事件1: 接受清剿任务 (ID: event_001) [未触发] [核心事件]
  简介: 玩家在村庄广场接受村民的清剿任务
  触发条件: 时间: 在场景中停留超过5分钟（游戏内时间） | 行为: 玩家指令包含"接受"、...
  描述预览: 年长的村民注意到你，走过来向你求助：...

【随机事件】（如遭遇战、发现财宝等，不触发场景转换）:
事件2: 打听消息 (ID: random_001) [未触发] [随机事件]
  简介: 玩家向村民打听关于魔物的消息
  触发条件: 行为: 玩家指令包含"打听"、...
  描述预览: 村民告诉你：...
```

**包含信息**：
- 事件ID和名称
- 事件类型（核心/随机）
- 已触发/未触发状态标记
- 事件简介（description字段）
- 触发条件（简化显示）
- 描述预览（description_template的前100字符）

**筛选逻辑**：
- 从`core_events.json`和`random_events.json`中筛选
- 检查事件的`associated_scenes`字段是否包含当前场景ID或房间ID
- 如果当前在房间中，也会匹配关联到父场景的事件

### 9. 【潜在怪物列表（隐藏信息，仅你可见）】

**说明**：当前场景/房间可能出现的怪物。

**数据来源**：
- `potential_monsters`：从场景/房间剧本的"里"部分解析，或从JSON文件加载

**格式示例**：
```
怪物1: 田野魔物
  绑定类型: 场景绑定
  出现条件: {"time_condition": "下午或傍晚", "location_condition": "田野深处", ...}
  描述模板: 一只巨大的魔物从庄稼中冲了出来！它有着锋利的爪子和凶狠的眼神...
```

**包含信息**：
- 怪物名称
- 绑定类型（场景绑定/房间绑定）
- 出现条件（JSON格式）
- 战斗描述模板

**绑定类型说明**：
- **场景绑定**：在该场景的任意房间都可能出现
- **房间绑定**：只在特定房间出现

### 10. 【可连接目标（隐藏信息，仅你可见）】

**说明**：当前场景/房间可以转换到的目标场景或房间。

**数据来源**：
- `connected_targets`：从`scene_network.json`中获取，根据当前场景/房间ID查找连接关系

**格式示例**：
```
- scene_002 (scene) - 前往田野 [触发事件: event_001]
- scene_003 (scene) - 前往村庄酒馆
- room_002_001 (room) - 进入田野入口 [前置条件: 击败田野中的魔物]
```

**包含信息**：
- 目标ID和类型（scene/room）
- 连接描述
- 触发事件（如果有）
- 前置条件（如果有）

**连接关系说明**：
- 从`scene_network.json`的`scene_network`或`room_network`中获取
- 如果当前在房间中，从`room_network`获取
- 如果在一级场景中，从`scene_network`获取

### 11. 【你的任务】

**说明**：LLM作为导演需要完成的任务。

**内容**：
1. **分析Agent响应**：仔细分析每个Agent的实际响应、状态变化和属性变化
2. **基于Agent响应评估是否应该触发事件**（根据Agent的实际行为、隐藏的触发条件和剧情需要）
   - **核心事件**：可以转换状态（场景转换）和推进剧本阶段，需要谨慎触发
   - **随机事件**：如遭遇战、发现财宝等，可以多次触发，不触发场景转换
   - **触发依据**：Agent的响应内容、行为描述、状态变化等
3. **基于Agent响应评估是否应该让怪物出现**（根据Agent的实际行为、隐藏的出现条件和剧情需要）
   - 如果Agent响应中提到了战斗、遭遇等，可以考虑触发怪物
4. 如果触发，选择合适的事件并生成描述
   - 优先考虑核心事件来推进剧情
   - 随机事件用于增加游戏性和沉浸感
   - 事件描述应该与Agent的实际响应相关
5. 如果怪物出现，选择合适的怪物并生成遭遇描述
   - 怪物描述应该与Agent的实际响应相关
6. **基于Agent响应决定是否转换场景/房间**（只能由核心事件驱动）
   - 如果Agent响应中明确表示移动、到达、进入等，可以考虑场景转换
7. 如果转换场景/房间，必须从可连接目标中选择
8. 保持剧情的自然流动：所有决策都应该与Agent的实际行为一致

### 12. 【场景连接网络规则】

**说明**：场景连接网络的工作原理和规则。

**内容**：
- **一级场景连接**：主场景之间的连接关系
- **房间连接**：房间之间的连接关系（通常在同一主场景内）
- **跨级连接**：房间可以直接连接到其他主场景
- **双向连接**：大部分场景可以互相到达
- **单向连接**：某些场景只能单向到达（需要前置条件）
- **事件驱动**：场景转换必须由事件触发，不能直接跳转
- **前置条件**：某些连接需要满足特定条件（如完成某个任务、达到某个状态）
- **LLM选择**：当事件触发时，从当前场景/房间的可连接目标中选择

### 13. 【原则】

**说明**：LLM作为导演应该遵循的原则。

**内容**：
- **所有决策都应该基于Agent的实际响应**，而不仅仅是玩家指令
- 根据Agent的实际行为、剧情逻辑和当前状态，自然地决定是否触发事件
- 根据Agent的实际行为、剧情逻辑和当前状态，自然地决定是否让怪物出现
- 场景转换必须由事件驱动
- **必须遵守场景连接网络**：只能转换到已定义的连接目标，不能跳转到未连接的目标
- 怪物与场景/房间绑定，只在对应场景/房间中可能出现
- 从可连接目标中选择最合适的目标，保持玩家体验的连贯性
- 所有决策应该与Agent的实际行为保持一致

### 14. 【导演工作流程】

**说明**：LLM作为导演的工作步骤。

**内容**：
1. **观察当前状态**：场景、角色状态、玩家指令
2. **分析Agent响应**：仔细阅读每个Agent的实际响应、状态变化和属性变化
3. **评估隐藏条件**：检查场景剧本中的事件触发条件（里部分）
4. **动态决策**：**基于Agent的实际响应**，根据剧情需要，决定是否触发事件
5. **推进剧情**：通过事件驱动场景转换和状态变化
6. **保持自然流动**：让剧情自然发展，符合逻辑，与Agent的实际行为一致

### 15. 【输出格式】

**说明**：要求LLM返回的JSON格式。

**内容**：
- JSON格式的详细说明
- 所有字段的要求和示例
- 时间消耗的参考范围
- 注意事项

## 数据来源总结

### 从文件系统读取

1. **场景/房间剧本**：
   - `scenarios/{scene_id}.md` - 一级场景剧本
   - `scenarios/{scene_id}/rooms/{room_id}.md` - 二级场景（房间）剧本

2. **事件定义**：
   - `core_events.json` - 核心事件列表
   - `random_events.json` - 随机事件列表

3. **场景连接网络**：
   - `scene_network.json` - 场景和房间的连接关系

4. **故事总览**：
   - `STORY_OVERVIEW.md` - 故事总览（包含剧情主线、场景池等）

5. **存档文件**：
   - `save/{theme}/{save_step}/SCENE_STATE.json` - 场景状态（包含已触发事件和进入时间）
   - `save/{theme}/{save_step}/SCENE_ID.txt` - 当前场景ID
   - `save/{theme}/{save_step}/ROOM_ID.txt` - 当前房间ID
   - `save/{theme}/{save_step}/GAME_TIME.json` - 游戏时间（包含当前时间和已流逝时间）
   - `save/{theme}/{save_step}/{character_id}.json` - 角色状态

### 从运行时获取

1. **玩家指令**：从函数参数传入
2. **Agent响应**：从`MultiAgentCoordinator.process_instruction()`获取，在Agent响应生成之后传递给导演评估器
3. **当前场景/房间ID**：从`SceneStateManager`获取
4. **场景状态**：从`SceneStateManager.get_scene_state()`获取
5. **已触发事件**：从`SceneStateManager.get_triggered_events()`获取
6. **游戏时间**：从`TimeManager.get_game_time()`获取
7. **进入时间**：从`SceneStateManager.get_enter_time()`获取

## 信息筛选逻辑

### 事件筛选

1. 加载`core_events.json`和`random_events.json`
2. 检查每个事件的`associated_scenes`字段
3. 如果当前场景ID或房间ID在`associated_scenes`中，则包含该事件
4. 如果当前在房间中，也会匹配关联到父场景的事件

### 怪物筛选

1. 加载当前场景/房间的剧本
2. 从"里"部分解析潜在怪物列表
3. 检查怪物的绑定类型和绑定目标
4. 如果绑定类型为"场景绑定"且绑定到当前场景，则包含
5. 如果绑定类型为"房间绑定"且绑定到当前房间，则包含

### 连接目标筛选

1. 从`scene_network.json`加载场景网络
2. 如果当前在房间中，从`room_network`中查找当前房间ID的连接
3. 如果在一级场景中，从`scene_network`中查找当前场景ID的连接
4. 返回所有可连接的目标

## 信息更新机制

### 场景状态更新

- 当事件触发时，通过`SceneStateManager.add_triggered_event()`记录
- 当场景转换时，通过`SceneStateManager.transition_scene()`更新场景ID和房间ID
- 状态变化通过`SceneStateManager.update_scene_state()`更新

### 时间更新

- 当LLM返回决策时，从`elapsed_time`字段获取时间消耗
- 通过`TimeManager.update_game_time()`更新游戏内时间
- 时间消耗会影响后续事件触发条件的判断

## 隐藏信息说明

以下信息对玩家是隐藏的，只提供给LLM：

1. **事件触发条件**：玩家看不到事件的触发条件，LLM根据这些条件判断是否触发
2. **怪物出现条件**：玩家看不到怪物的出现条件，LLM根据这些条件判断是否让怪物出现
3. **场景连接网络**：玩家看不到完整的场景连接关系，LLM根据网络选择转换目标
4. **前置条件**：玩家看不到场景转换的前置条件，LLM需要检查这些条件
5. **导演提示**：事件和怪物定义中的导演提示，帮助LLM做出决策

## 信息传递流程

```
1. MultiAgentCoordinator.process_instruction()
   ↓
2. 获取当前场景/房间ID
   ↓
3. 加载场景/房间剧本
   ↓
4. Agent响应生成（并行处理）
   ↓
5. 收集Agent实际响应
   ↓
6. 获取潜在事件和怪物
   ↓
7. 获取可连接目标
   ↓
8. 获取场景状态和已触发事件
   ↓
9. 构建导演上下文（director_context，包含Agent响应）
   ↓
10. DirectorEvaluator.evaluate_as_director()
   ↓
11. 构建Prompt（包含所有信息，包括Agent响应）
   ↓
12. 调用LLM API
   ↓
13. 解析LLM返回的JSON
   ↓
14. 返回决策结果
```

## 注意事项

1. **Agent响应的重要性**：**Agent响应是导演评估的重要依据**，所有决策都应该基于Agent的实际响应，而不仅仅是玩家指令
2. **信息完整性**：所有必要的信息（包括Agent响应）都应该传递给LLM，确保LLM能够做出正确的决策
3. **信息准确性**：确保从文件系统读取的信息是最新的，反映当前游戏状态
4. **信息筛选**：只传递与当前场景/房间相关的信息，避免信息过载
5. **隐藏信息**：明确区分玩家可见信息和LLM可见信息
6. **状态同步**：确保场景状态、已触发事件等信息与存档文件同步
7. **Agent响应格式**：Agent响应会被限制长度（通常前150-200字符），但应该包含关键的行为描述和状态变化

## 系统中所有LLM调用场景

本文档主要说明**导演评估**传递给LLM的信息，但系统中还有其他LLM调用场景。以下是完整的LLM调用场景列表及其信息传递（按执行顺序排列）：

### 1. Agent响应生成（步骤4.1）

**位置**：`services/agent.py` → `Agent.process_instruction()`

**调用时机**：在处理玩家指令时，为每个角色并行调用LLM生成响应

**传递给LLM的信息**：

**系统提示词（System Prompt）包含**：
- **角色信息**：
  - 角色名称（**不包含角色ID**）
  - 角色描述（description）
  - 角色属性（attributes）：包括性格、技能、装备、状态等
  - 角色说话风格和语气
- **场景信息**（**只包含"表"信息，不包含"里"信息**）：
  - 当前场景描述（从场景剧本的"表"部分获取，玩家可见的描述文本）
  - 场景状态（位置、时间、环境等，仅玩家可见的状态）
  - **不包含**：场景ID、房间ID等技术性标识符（这些是系统内部使用的，Agent不需要知道）
  - **不包含**：场景剧本的"里"部分（隐藏信息、事件触发条件、怪物出现条件、导演指引等）
  - **不包含**：场景连接网络、事件定义、怪物定义等隐藏的游戏机制
- **玩家角色**：玩家扮演的角色名称
- **对话历史**：最近5条对话记录（从`HISTORY.json`读取，格式化为文本）
- **角色剧本扩展**：从`{character_id}_script.json`读取（如果存在，但只包含"表"信息）

**重要：表里区分**：
- **Agent只能看到"表"信息**：玩家可见的场景描述、状态信息、环境描述
- **Agent不能看到"里"信息**：
  - 场景ID、房间ID等技术性标识符
  - 事件触发条件、怪物出现条件
  - 场景连接网络、可连接目标
  - 导演指引、隐藏的游戏机制
- **Agent作为智能体**：只需要了解场景描述和状态，像角色在游戏中看到的那样，不需要知道技术性标识符和隐藏的游戏机制

**用户消息（User Message）包含**：
- **玩家指令**：玩家输入的原始指令
- **输出要求**：
  - 执行指令（可能因环境失败，需说明原因）
  - 描述具体行动过程，不要只说"执行了"
  - 如果遇到预期事件，必须立即停止，描述情况等待玩家
  - 队伍一致性：如果队伍在一起行动，所有角色应该在同一个时刻停止
  - 主动观察环境变化（天气/声音/地形等），简洁描述
  - 严格遵循角色说话风格和性格特点，保持语气一致

**LLM返回格式**：详见`LLM返回JSON格式详细说明.md`第1节

**特点**：
- 并行处理：所有Agent同时调用LLM
- 个性化：每个Agent根据角色设定生成独特的响应
- **注意**：统一停止点的功能由导演评估承担，导演评估会在Agent响应生成之后，基于Agent的实际响应决定事件触发和统一停止点

---

### 3. 环境变化分析（步骤6）

**位置**：`services/environment_analyzer.py` → `EnvironmentAnalyzer.analyze_environment_changes()`

**调用时机**：在Agent响应生成之后，分析所有响应对环境的影响

**传递给LLM的信息**：

**系统提示词（System Prompt）包含**：
- **场景内容**：当前场景描述和状态（限制长度，通常前1500字符）
- **Agent响应**：所有Agent的响应文本（格式化为文本，限制长度，通常前1500字符）
  - 格式：`【角色名】\n响应文本`
- **预设事件**（如果存在）：场景中包含的预设事件列表
- **剧情节奏评估结果**：
  - 是否需要触发事件（should_trigger）
  - 触发原因（trigger_reason）
  - 如果评估认为需要触发事件，会强制要求生成至少1个重大事件

**分析要求**：
1. **场景变化（表/里）**：
   - surface: time, location{region/specific_location/coordinates/environment}, current_narrative, goal, resources
   - hidden: final_goal, potential_enemies, risk_hints
2. **重大事件列表**：
   - 根据当前行动和场景背景主动识别事件
   - 如果场景中有预设事件，在适当时候应该触发（优先考虑预设事件）
   - 事件应该具体、有画面感
3. **决策点检测**：
   - 判断是否需要玩家做出决策（如路线选择、行动方式、是否调查等）
   - 如果发现线索、异常、需要选择的情况，必须标记为决策点
4. **状态总结**：
   - 当前位置和时间（即使没有变化也要显示当前状态）
   - 目标进度
   - 下一步建议（2-3个可选行动，要具体可操作）

**关键规则**：
- **位置更新（最高优先级）**：位置必须反映角色当前实际所在的地点，必须与事件发生地点一致
- **事件触发**：如果剧情节奏评估显示需要触发事件，必须生成至少1个事件
- **其他**：时间明显流逝需更新time；如果发现线索/异常/需要选择，必须标记为决策点

**LLM返回格式**：详见`LLM返回JSON格式详细说明.md`第3节

**特点**：
- 综合分析：分析所有Agent的响应
- 环境更新：更新场景描述和状态
- **位置更新优先级最高**：位置必须与事件发生地点一致

---

### 4. 导演评估（步骤6.1，本文档重点）

**位置**：`services/director_evaluator.py` → `DirectorEvaluator.evaluate_as_director()`

**调用时机**：在Agent响应生成之后，基于Agent的实际响应进行导演评估

**传递给LLM的信息**：本文档详细说明的所有14个部分

**LLM返回格式**：详见`LLM返回JSON格式详细说明.md`

**特点**：
- **基于Agent实际响应**：所有决策都应该基于Agent的实际响应
- 事件驱动：场景转换必须由事件驱动
- 遵守连接网络：只能转换到已定义的连接目标

---

### 5. 响应格式化（步骤8）

**位置**：`services/response_formatter.py` → `ResponseFormatter.format_responses_for_player()`

**调用时机**：在状态更新之后，将原始响应转换为玩家视角的文本

**传递给LLM的信息**：

**系统提示词（System Prompt）包含**：
- **玩家角色**：玩家扮演的角色名称
- **场景信息**：当前场景描述（限制长度，通常前500字符）
- **Agent响应**：所有Agent的原始响应文本（格式化为文本，限制长度，通常前1000字符）
  - 格式：`【角色名】\n响应文本`

**格式化要求**：
1. **玩家视角描述**：自然融入对话和行动
2. **严格保持角色语气**（最高优先级）：每个角色的说话风格和语气必须严格保持
3. **每个角色1-2句**：摘要简短
4. **可适当添加环境描述**

**摘要要求（必须严格遵守）**：
- **第三人称视角**：禁止使用"我"、"我们"、"咱们"等第一人称
- **以叙事为主，不要重复人物行动**：
  - 不要逐条列举角色行动（错误："艾伦做了X，莉娅做了Y"）
  - 用流畅叙事描述整体场景和事件发展（正确："黎明的薄雾尚未散去，冒险者小队整装待发。凯·盗贼率先踏出公会大门..."）
  - 将多个角色行动融合成连贯叙事，禁止"角色名：行动内容"格式
- **小说风格**：语言生动优美，有画面感，可描写环境氛围，包含动作细节和心理暗示，叙述流畅自然

**LLM返回格式**：详见`LLM返回JSON格式详细说明.md`第4节

**特点**：
- 玩家视角：转换为玩家角色的视角
- 小说风格：生成第三人称、小说风格的描述
- 保持角色语气：严格保持每个角色的说话风格

---

### 6. 问题回答（独立功能）

**位置**：`services/question_service.py` → `QuestionService.answer_question()`

**调用时机**：当玩家提出问题时（独立于主流程）

**传递给LLM的信息**：
- **玩家问题**：玩家提出的问题文本
- **场景内容**：当前场景描述
- **角色信息**：所有角色的信息
- **对话历史**：最近对话记录
- **回答要求**：要求根据场景和角色信息回答问题

**LLM返回格式**：
- 回答文本（文本格式）

**特点**：
- 独立功能：不参与主流程
- 信息查询：用于回答玩家问题

---

## LLM调用流程总结

```
玩家指令
  ↓
1. Agent响应生成（LLM调用1，并行，每个角色，步骤4.1）
   - 输入：角色信息、场景、指令、历史
   - 输出：角色响应文本、状态变化、属性变化（JSON）
  ↓
2. 环境变化分析（LLM调用2，步骤6）
   - 输入：场景、Agent响应
   - 输出：场景变化描述、状态更新（JSON）
  ↓
3. 导演评估（LLM调用3，基于Agent响应，步骤6.1）← 本文档重点
   - 输入：本文档详细说明的所有14个部分
   - 输出：事件触发、怪物出现、场景转换决策（JSON）
   - **负责决定事件触发和统一停止点，确保所有Agent在同一时刻停止**
  ↓
4. 响应格式化（LLM调用4，步骤8）
   - 输入：Agent响应、场景、玩家角色
   - 输出：格式化响应文本、摘要（JSON）
  ↓
返回给玩家
```

**注意**：
- 本文档主要说明**导演评估**（LLM调用4）传递给LLM的信息
- 其他LLM调用的信息传递各不相同，详见各自的实现文件
- 导演评估是最重要的LLM调用，因为它决定了事件触发、怪物出现和场景转换
- **所有LLM调用都通过`ChatService`统一管理**，支持多个API平台（DeepSeek、OpenAI、Aizex）

