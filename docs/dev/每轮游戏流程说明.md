# 每轮游戏流程说明

## 完整流程概览

每轮游戏从接收玩家指令开始，到返回格式化响应结束，包含以下主要步骤：

```
玩家指令
  ↓
1. 加载场景和对话历史
  ↓
2. 加载所有角色
  ↓
3. Agent响应生成（LLM调用1 - 并行）
  ↓
4. 聚合响应
  ↓
5. 导演评估（LLM调用2 - 包含两部分工作）
   ├─ 第一部分：环境变化分析
   └─ 第二部分：决策制定
  ↓
6. 更新Agent实际状态
  ↓
7. 更新环境状态
  ↓
8. 格式化响应（LLM调用3）
  ↓
9. 保存对话历史
  ↓
返回结果给玩家
```

---

## 详细步骤说明

### 步骤1：加载场景和对话历史

**操作**：
- 获取当前场景ID和房间ID（从`SCENE_STATE.json`）
- 加载场景内容（从场景剧本的"表"部分生成）
- 加载最近5条对话历史

**输出**：
- `scene_content`：场景内容（只包含"表"信息，玩家可见）
- `current_scene_id`、`current_room_id`：当前场景/房间ID（技术性标识符）
- `conversation_history_text`：对话历史文本

**LLM交互**：无

---

### 步骤2：加载所有角色

**操作**：
- 从角色库中加载所有角色（或指定角色）
- 读取每个角色的状态文件（`{character_id}.json`）

**输出**：
- `characters`：角色列表，包含角色属性、状态等

**LLM交互**：无

---

### 步骤3：Agent响应生成（LLM调用1）

**操作**：
- 为每个角色创建Agent实例
- **并行调用LLM**，每个Agent独立生成响应
- Agent考虑：**自身状态 + 玩家指令 + 当前环境**

**输入信息（Agent只能看到"表"信息）**：
1. 自身状态（角色属性、HP、MP等）
2. 玩家指令
3. 当前环境（场景描述、场景状态，只包含玩家可见信息）
4. 对话历史（最近5条）
5. 角色剧本扩展（如果存在）

**LLM返回格式**：
```json
{
    "response": "角色的想法和决策（文本）",
    "state_changes": {"surface": {...}, "hidden": {...}},
    "attribute_changes": {...},
    "execution_result": {
        "success": true/false,
        "failure_reason": "失败原因（如果失败）",
        "actual_outcome": "实际执行结果描述"
    }
}
```

**输出**：
- `agent_responses`：所有Agent的响应列表

**关键说明**：
- **Agent只负责"产生想法"**，不负责实际执行
- Agent只能看到"表"信息，不能看到技术性标识符和"里"信息
- 所有Agent并行处理，提高效率

---

### 步骤4：聚合响应

**操作**：
- 合并所有Agent的响应
- 分离表/里信息

**输出**：
- `aggregated`：聚合后的响应（包含表/里信息）

**LLM交互**：无

---

### 步骤5：导演评估（LLM调用2）⭐ **核心步骤**

**重要**：这是一个LLM调用，包含两部分工作，在同一个prompt中顺序完成。

#### 5.1 第一部分：环境变化分析

**职责**：
- 分析Agent的想法/决策对环境的影响（如移动改变位置、战斗改变场景状态等）
- 分析Agent的想法/决策的实际执行情况（基于环境因素，如遇到障碍、怪物逃跑等）
- 生成Agent执行结果（成功/失败、失败原因、实际结果等）
- 更新场景描述和场景状态（位置、时间等）

**注意**：环境变化分析**不会决定怪物出现**，怪物出现由决策制定部分决定。

#### 5.2 第二部分：决策制定

**职责**：
- 基于环境变化分析结果，决定是否触发事件
- 基于环境变化分析结果，决定是否让怪物出现
- 基于环境变化分析结果，决定是否转换场景/房间
- 决定时间消耗（`elapsed_time`）
- **统一停止点**：确保所有Agent在同一时刻停止

**输入信息（导演评估可以看到完整信息，包括"里"信息）**：
1. 【当前场景状态】（包含场景ID、房间ID等技术性标识符）
2. 【当前时间信息】
3. 【当前事件状态】
4. 【玩家指令】
5. 【Agent的想法/决策】（最重要）
6. 【场景描述（玩家可见）】
7. 【角色状态】
8. 【当前场景下的可能事件（隐藏信息，仅你可见）】
9. 【潜在怪物列表（隐藏信息，仅你可见）】
10. 【可连接目标（隐藏信息，仅你可见）】
11. 【你的任务】
12. 【场景连接网络规则】
13. 【原则】
14. 【导演工作流程】
15. 【输出格式】

**LLM返回格式**：
```json
{
    "environment_analysis": {
        "updated_scene_description": "更新后的场景描述",
        "scene_state_changes": {
            "location": "新位置",
            "time": "时间变化",
            "weather": "天气变化"
        },
        "agent_execution_results": [
            {
                "character_id": "agent_001",
                "character_name": "勇者",
                "execution_result": {
                    "success": true,
                    "failure_reason": null,
                    "actual_outcome": "实际执行结果描述"
                }
            }
        ]
    },
    "director_decision": {
        "trigger_event": "event_001",
        "event_description": "事件描述",
        "appear_monster": "田野魔物",
        "monster_description": "怪物出现描述",
        "transition_target": "scene_002",
        "transition_type": "scene",
        "elapsed_time": 5.0,
        "reasoning": "决策理由"
    }
}
```

**输出**：
- `environment_analysis`：环境变化分析结果
- `director_decision`：导演决策结果

**后续处理**：
- 更新游戏时间（根据`elapsed_time`）
- 如果触发事件，记录已触发的事件
- 如果出现怪物，记录怪物信息（怪物作为环境的一部分）
- 如果转换场景/房间，执行场景转换

---

### 步骤6：更新Agent实际状态（步骤6.5）

**操作**：
- **依据环境变化分析结果**，确认Agent的实际状态变化（可能与Agent的预期不同）
- **应用导演决策带来的变化**（事件触发、怪物出现、场景转换对Agent状态的影响）
- 合并状态变化并更新到角色状态文件

**更新依据**：
1. **环境变化分析结果**：Agent响应的实际执行情况
2. **Agent的预期状态变化**：Agent在响应中声明的状态变化
3. **导演决策带来的变化**：
   - 事件触发：从事件的`effects.character_changes`中获取对Agent状态的影响
   - 怪物出现：可能影响Agent的状态（如进入战斗状态、获得战利品等）
   - 场景转换：可能影响Agent的状态（如位置变化、环境适应等）

**输出**：
- 更新后的角色状态文件（`{character_id}.json`）

**LLM交互**：无

---

### 步骤7：更新环境状态

**操作**：
- 从`environment_analysis`中提取场景状态变化（位置、时间等）
- 从`director_decision`中提取决策结果（事件、怪物、场景转换）
- 更新场景状态文件（`SCENE_STATE.json`）
- 更新场景描述文件（`SCENE.md`）

**更新内容**：
- 场景位置、时间等状态变化
- 已触发的事件列表
- 出现的怪物（怪物作为环境的一部分，状态保存在环境状态中）
- 场景转换后的新场景ID和房间ID

**输出**：
- 更新后的场景状态文件

**LLM交互**：无

---

### 步骤8：格式化响应（LLM调用3）

**操作**：
- 调用LLM将原始响应转换为玩家视角文本
- 合并表/里信息
- 生成第三人称、小说风格的摘要

**输入**：
- Agent响应
- 场景信息（可能包含更新后的环境状态）
- 格式化要求

**LLM返回格式**：
- 玩家视角的文本描述
- 包含角色对话和行为
- 包含场景变化
- 第三人称、小说风格的摘要

**输出**：
- `formatted`：格式化后的响应（包含表/里信息）

---

### 步骤9：保存对话历史

**操作**：
- 如果创建了新步骤，保存对话历史
- 记录玩家指令和响应摘要

**输出**：
- 更新后的对话历史文件（`HISTORY.json`）

**LLM交互**：无

---

## 关键流程特点

### 1. LLM调用总结

**总共3个LLM调用**：
1. **LLM调用1**：Agent响应生成（并行，每个Agent一个调用）
2. **LLM调用2**：导演评估（一个调用，包含两部分工作）
   - 第一部分：环境变化分析
   - 第二部分：决策制定
3. **LLM调用3**：响应格式化

### 2. 信息流向

```
环境状态（表信息）
  ↓
Agent响应生成（LLM调用1）
  ↓
Agent响应（包含预期状态变化）
  ↓
导演评估（LLM调用2）
  ├─ 环境变化分析 → 确认实际执行情况
  └─ 决策制定 → 决定事件/怪物/场景转换
  ↓
更新Agent实际状态（依据环境变化分析结果和导演决策）
  ↓
更新环境状态（从environment_analysis和director_decision中提取）
  ↓
格式化响应（LLM调用3）
  ↓
返回给玩家
  ↓
下一次循环（考虑新环境状态）
```

### 3. 表里区分

**Agent（只能看到"表"信息）**：
- 场景描述（玩家可见）
- 场景状态（从角色视角观察到的）
- 角色信息（角色名和属性，不包含角色ID）
- **不包含**：场景ID、房间ID、事件触发条件、怪物出现条件等

**导演评估（可以看到完整信息，包括"里"信息）**：
- 场景ID和房间ID（技术性标识符）
- 事件列表（包含触发条件等"里"信息）
- 怪物列表（包含出现条件等"里"信息）
- 连接目标（包含目标ID、前置条件等）

### 4. 环境变化分析的作用

- **分析Agent响应的实际执行情况**：基于环境因素，判断Agent的想法/决策是否成功执行
- **生成Agent执行结果**：成功/失败、失败原因、实际结果等
- **更新环境状态**：位置、时间等场景状态变化
- **为决策制定提供依据**：决策制定基于环境变化分析结果进行

### 5. 决策制定的作用

- **决定事件触发**：基于环境变化分析结果，决定是否触发事件
- **决定怪物出现**：基于环境变化分析结果，决定是否让怪物出现
- **决定场景转换**：基于环境变化分析结果，决定是否转换场景/房间
- **统一停止点**：确保所有Agent在同一时刻停止

### 6. 状态更新时机

- **Agent状态更新**：在导演评估之后，依据环境变化分析结果和导演决策带来的变化
- **环境状态更新**：在导演评估之后，从`environment_analysis`和`director_decision`中提取信息更新

---

## 注意事项

1. **导演评估是核心**：这是新剧本系统的核心LLM调用，环境变化分析和决策制定都是导演评估的职责
2. **环境变化分析先于决策制定**：在同一个LLM调用中，先完成环境变化分析，然后基于分析结果进行决策制定
3. **Agent只负责"产生想法"**：Agent根据观察到的信息产生想法和决策，实际执行由导演评估负责
4. **统一停止点**：统一停止点功能由导演评估承担，不再需要提前进行剧情节奏评估
5. **怪物作为环境的一部分**：怪物出现后作为环境的一部分，状态保存在环境状态中，不再独立维护角色卡

